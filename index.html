<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
    <link rel="stylesheet" href="index.css">
    <script src="https://unpkg.com/vue@3.2.12/dist/vue.global.js"></script>
    <link rel="icon" href="https://blog.xn--8mrw2phtl.eu.org/image/favicon.png">

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.20/dist/sweetalert2.min.css">
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.20/dist/sweetalert2.all.min.js"></script>


    <script src="./utils/audio.js"></script>
    <title>emoäº†ä¸ªji</title>
</head>

<body>
    <div id="app">
        <h1>emoäº†ä¸ªji</h1>
        <h3>ç¬¬ {{ level }} å…³</h3>
        <header>
            <span class="btn" @click="handleStart">å¼€å§‹</span>
            <!--<span class="btn" @click="handleReset">æ‰“ä¹±</span>-->
            <span class="btn" @click="handleSwitch('prev')">è¿”å›</span>
            <span class="btn" @click="handleSwitch('next')">è·³è¿‡</span>
            <p class="center">
                <select v-model="config.row">
                    <option :value="item" v-for="item in [3,4,5,6,7,8]">{{ item }}</option>
                </select>
                <span>&ensp;è¡Œ&ensp;&ensp;&ensp;&ensp;</span>
                <select v-model="config.col">
                    <option :value="item" v-for="item in [3,4,5,6,7,8]">{{ item }}</option>
                </select>
                <span>&ensp;åˆ—</span>
            </p>
        </header>
        <!-- å®¹å™¨ -->
        <div class="wrap">
            <div class="container" :style="setContainerStyle()">
                <div class="card-wrap" v-for="(item, index) in cards" :key="index" :style="setCardStyle(item)">
                    <div class="card" :class="[item.not && 'is-allow', item.id]" :style="setAnimation(item)" @click="clickCard(item, index)">
                        <span>{{ item.icon }}</span>
                    </div>
                </div>
            </div>
        </div>
        <!-- å¡æ§½ -->
        <div class="card-slot"></div>
    </div>
    <script>
        const {
            reactive,
            ref,
            toRefs,
            setup,
            computed,
            onMounted,
            watch
        } = Vue;
        const App = {
            setup() {
                // åˆå§‹åŒ–éŸ³ä¹æ§ä»¶
                const audio = new CustomAudio({
                    template: '#app',
                    bgmSrc: './static/bgm.mp3',
                    clickBgm: './static/clickBgm.mp3'
                });
                window.customAudio = audio;
                /**
                 * å®¹å™¨æ ·å¼
                 */
                const setContainerStyle = () => {
                        const {
                            base,
                            row,
                            col
                        } = config;
                        return `height: ${base * row}px; width: ${base * col}px`;
                    }
                    /**
                     * è®¾ç½®å¡ç‰‡ä½ç½®
                     */
                const setCardStyle = ({
                        x,
                        y
                    }) => {
                        return `
            transform: translateX(${x}px) translateY(${y}px);
          `;
                    }
                    /**
                     * è®¾ç½®å¡ç‰‡åŠ¨ç”»
                     */
                const setAnimation = ({
                    id,
                    clear,
                    display
                }) => {
                    let isClear = ''
                    if (clear) {
                        isClear = `animation: scaleDraw ${config.animationTime}ms;`
                    }
                    if (display) {
                        isClear += 'display: none;';
                    }
                    return isClear;
                }

                /**
                 * éšæœºç”ŸæˆæŒ‡å®šé•¿åº¦id
                 */
                const randomCreateId = (length) => {
                    return (Math.random() + new Date().getTime()).toString(32).slice(0, length);
                }

                onMounted(() => {
                    getDoMInfo();
                })
                const getDoMInfo = () => {
                    const containerDom = document.querySelector('.container');
                    data.containerInfo = containerDom.getBoundingClientRect();
                    const cardSlotDom = document.querySelector('.card-slot');
                    data.cardSlotInfo = cardSlotDom.getBoundingClientRect();
                }

                // é…ç½®é¡¹
                const config = reactive({
                    // ä¸å¡ç‰‡å®½åº¦ä¸€è‡´
                    base: 40,
                    // å¡æ§½ä¸­æœ€é•¿å¡ç‰‡é•¿åº¦
                    selectMaxLength: 7,
                    // å¡æ§½è®¾å®šå¤šå°‘ä¸ªç›¸åŒå¡ç‰‡å°±æ¶ˆæ‰
                    maxCount: 3,
                    // åŠ¨ç”»æ—¶é—´ æ¯«ç§’
                    animationTime: 400,
                    // æœ€å¤§å…³æ•°
                    maxLevel: 10,
                    // è¡Œ
                    row: 8,
                    // åˆ—
                    col: 8
                });

                const data = reactive({
                    level: 1,
                    cards: [],
                    select: new Map(),
                    containerInfo: null,
                    cardSlotInfo: null
                });

                /**
                 * ç­‰çº§åˆ‡æ¢ é‡ç½®æ¸¸æˆ 
                 */
                watch(() => data.level, () => {
                    handleReset();
                });
                watch(() => config.row, () => {
                    getDoMInfo();
                    data.select.clear();
                    data.cards = [];
                });
                watch(() => config.col, () => {
                    getDoMInfo();
                    data.select.clear();
                    data.cards = [];
                });

                /**
                 * å¡æ§½å·²å­˜åœ¨å¡ç‰‡é•¿åº¦
                 */
                const selectLength = computed(() => {
                    let length = 0;
                    data.select.forEach((item) => {
                        length += item.length;
                    })
                    return length;
                });

                /**
                 * å¡ç‰‡é»˜è®¤å›¾æ ‡
                 */
                const defaultIcons = ['ğŸ˜…', 'ğŸ¶', 'ğŸ', 'ğŸ¦„', 'ğŸ‘»', 'ğŸµ', 'ğŸ·', 'ğŸ¼', 'ğŸ¸', 'ğŸ„', 'ğŸ’©', 'ğŸƒ'];
                /**
                 * æ ¹æ®ç­‰çº§é€‰æ‹©å¡ç‰‡å›¾æ ‡çš„å¤šç§é€‰æ‹©
                 */
                const icons = computed(() => {
                    return defaultIcons.slice(0, 2 * data.level);
                });

                /**
                 * å¡ç‰‡é»˜è®¤åç§»å€¼ éšæ„è®¾å®š
                 */
                const defaultOffsetValue = [7, -7, 20, -20, 25, -25, 33, -33, 40, -40];
                const defaultOffsetValueLength = defaultOffsetValue.length;

                /**
                 * å¡ç‰‡é»˜è®¤ç”Ÿæˆ3çš„å€æ•° ä¸æ˜¯3çš„å€æ•°çš„åˆ™ä¸å¯èƒ½é€šå…³
                 */
                const defaultRounds = [3, 6, 9, 3, 6, 3, 3, 6, 3];


                /**
                 * åˆå§‹åŒ–
                 */
                const init = () => {
                    console.log('init game--->', icons.value);
                    data.select.clear();
                    for (const i in icons.value) {
                        // éšæœº3çš„å€æ•°
                        const rounds = defaultRounds[Math.floor(Math.random() * defaultRounds.length)];
                        for (let k = 0; k < rounds; k++) {
                            createCardInfo(icons.value[i]);
                        }
                    }
                    checkShading();
                }

                /**
                 * åˆ›å»ºå¡ç‰‡å±æ€§
                 * id icon x y ã€‚ã€‚ã€‚
                 */
                const createCardInfo = (icon) => {
                    // åç§»
                    const offset = defaultOffsetValue[Math.floor(defaultOffsetValueLength * Math.random())];
                    // éšæœº8åˆ— 8è¡Œ
                    const row = Math.floor(Math.random() * config.row);
                    const col = Math.floor(Math.random() * config.col);

                    let x = col * config.base + offset;
                    let y = row * config.base + offset;

                    data.cards.push({
                        id: randomCreateId(6),
                        icon,
                        x,
                        y,
                        // æ§åˆ¶é®ç½©å±‚
                        not: true,
                        // æ˜¯å¦åœ¨å¡æ§½ä¸­ 0å¦ 1æ˜¯
                        status: 0,
                        // æ˜¯å¦æ¸…é™¤
                        clear: false,
                        // éšè—
                        display: false
                    })
                }

                /**
                 * æ˜¯å¦èƒ½ç‚¹å‡» æ˜¯å¦æœ‰é˜´å½±
                 */
                const checkShading = () => {
                    const cards = data.cards;
                    for (let i = 0; i < cards.length; i++) {
                        const cur = cards[i];
                        cur.not = true;
                        // å·²æ¶ˆå®Œå¡ç‰‡å’Œåœ¨å¡æ§½å†…çš„å¡ç‰‡è·³è¿‡
                        if (cur.status !== 0 || cur.display) continue;
                        const {
                            x: x1,
                            y: y1
                        } = cur;
                        const x2 = x1 + config.base,
                            y2 = y1 + config.base;

                        for (let j = i + 1; j < cards.length; j++) {
                            const compare = cards[j];
                            // å·²æ¶ˆå®Œå¡ç‰‡å’Œåœ¨å¡æ§½å†…çš„å¡ç‰‡è·³è¿‡
                            if (compare.status !== 0 || compare.display) continue;
                            const {
                                x,
                                y
                            } = compare;
                            if (!(y + config.base <= y1 || y >= y2 || x + config.base <= x1 || x >= x2)) {
                                cur.not = false;
                                break;
                            }
                        }
                    }
                }

                /**
                 * å¼€å§‹æ¸¸æˆ
                 */
                const handleStart = () => {
                    if (data.cards.length) {
                        data.cards.length = 0;
                        data.select.clear();
                        init();
                        //audio.replay();
                    }
                    audio.play();
                    init();
                }

                /**
                 * é‡ç½®æ¸¸æˆ
                 */
                const handleReset = () => {
                    // æ¸…ç©ºå·²æœ‰çš„å¡ç‰‡
                    data.cards.length = 0;
                    data.select.clear();
                    init();
                    //audio.replay();
                }

                /**
                 * åˆ‡æ¢å…³å¡
                 */
                const handleSwitch = (type) => {
                    if (type === 'prev') {
                        if (data.level === 1) {
                            data.level = 13;
                        }
                        data.level--;
                    } else {
                        if (data.level === defaultIcons.length) {
                            data.level = 0;
                        }
                        data.level++;
                    }
                }

                /**
                 * ç‚¹å‡»å¡ç‰‡
                 */
                const clickCard = async(item, index) => {
                    // å¡æ§½ä¸­çš„å¡ç‰‡ä¸å…è®¸ç‚¹å‡»
                    if (item.status === 1) return;

                    // æ’­æ”¾ç‚¹å‡»éŸ³ä¹
                    audio.rePlayClickBgm();

                    const length = selectLength.value;
                    const {
                        selectMaxLength
                    } = config;
                    if (item.not && length < selectMaxLength) {
                        const cards = data.cards;
                        const currentCard = cards[index];
                        currentCard.status = 1;

                        // åˆ·æ–°å¡æ§½ä½ç½®
                        await refreshCardPosition(currentCard);
                        // åˆ·æ–°è¢«é®æŒ¡å¡ç‰‡
                        checkShading();
                    };

                    // æ ¡éªŒå¡ç‰‡å¡æ§½å¡ç‰‡æ•°é‡é•¿åº¦
                    setTimeout(() => {
                        if (selectLength.value >= config.selectMaxLength) {

                            Swal.fire({
                                title: 'æ§½ä½å·²æ»¡', // ç©ºæ ‡é¢˜
                                text: '',
                                icon: false, // ä¸æ˜¾ç¤ºå›¾æ ‡
                                confirmButtonText: 'é‡æ–°å¼€å§‹', // æ›´æ”¹æŒ‰é’®æ–‡å­—
                                showCancelButton: false, // ä¸æ˜¾ç¤ºå–æ¶ˆæŒ‰é’®
                                width: 'auto', // è®¾ç½®å®½åº¦ä¸ºè‡ªé€‚åº”
                            });

                            handleReset();
                        }
                    }, config.animationTime);

                }

                /**
                 * åˆ·æ–°å¡æ§½å¡ç‰‡ä½ç½®
                 */
                const refreshCardPosition = (item) => {
                    const {
                        x,
                        y
                    } = data.cardSlotInfo;
                    const {
                        top,
                        left
                    } = data.containerInfo;

                    if (item) {
                        // æ˜¯å¦å­˜åœ¨
                        const cards = data.select.get(item.icon);
                        if (cards) {
                            cards.push(item);
                            checkSelectQueue(cards);
                        } else {
                            data.select.set(item.icon, [item]);
                        }
                    }
                    // é‡æ–°åˆ·æ–°ä½ç½®
                    let index = 0;
                    const poor = (x < left) ? -(left - x) : (x - left);
                    data.select.forEach((item) => {
                        item.forEach((card) => {
                            card.x = index * config.base + poor + config.base / 2;
                            card.y = y - top + 12;
                            index++;
                        });
                    });
                }

                /**
                 * æ ¡éªŒå¡æ§½ä¸­æ˜¯å¦3ä¸ªç›¸åŒçš„å­˜åœ¨
                 */
                const checkSelectQueue = (cards) => {
                    if (cards.length === config.maxCount) {
                        cards.forEach((item) => {
                            item.clear = true;
                        })

                        setTimeout(() => {
                            // åˆ é™¤å¡æ§½ä¸­å¡ç‰‡
                            data.select.delete(cards[0].icon);
                            // åˆ é™¤cardsä¸­çš„å¡ç‰‡ è½¯åˆ é™¤ displayä»£æ›¿
                            cards.forEach((item) => {
                                item.display = true;
                            })
                        }, config.animationTime - 100);

                        setTimeout(() => {
                            // å±æ€§å¡æ§½å¡ç‰‡ä½ç½®
                            refreshCardPosition();

                            // æ ¡éªŒæ˜¯å¦å¡ç‰‡åˆ—è¡¨æ˜¯å¦è¿˜æœ‰æœªæ¶ˆé™¤çš„å¡ç‰‡
                            const hasCards = data.cards.filter((item) => !item.display);
                            const level = data.level + 1;
                            if (!hasCards.length && level < config.maxLevel) {
                                data.level++;
                            }
                            if (!hasCards.length && level >= config.maxLevel) {
                                {
                                    Swal.fire({
                                        title: 'æ­å–œæ‚¨é€šè¿‡å…¨éƒ¨å…³å¡', // ç©ºæ ‡é¢˜
                                        text: '',
                                        icon: 'success', // ä½¿ç”¨å–œåº†çš„å›¾æ ‡
                                        confirmButtonText: 'å†æ¥ä¸€æ¬¡', // æ›´æ”¹æŒ‰é’®æ–‡å­—
                                        showCancelButton: false, // ä¸æ˜¾ç¤ºå–æ¶ˆæŒ‰é’®
                                        width: 'auto', // è®¾ç½®å®½åº¦ä¸ºè‡ªé€‚åº”
                                    });
                                    data.level = 1;
                                }
                            }
                        }, config.animationTime + 100);
                    }
                }

                const dataRefs = toRefs(data);
                return {
                    ...dataRefs,
                    config,
                    handleStart,
                    setContainerStyle,
                    setCardStyle,
                    setAnimation,
                    handleSwitch,
                    handleReset,
                    clickCard
                }
            }
        }
        Vue.createApp(App).mount('#app');
    </script>
    <iframe id="c_iframe" height="0" width="0" src="https://blog.xn--tiyy81g.eu.org/games/agent.html" style="display:none"></iframe>
    <script type="text/javascript">
        (function autoHeight() {
            var b_width = Math.max(document.body.scrollWidth, document.body.clientWidth);
            var b_height = Math.max(document.body.scrollHeight, document.body.clientHeight);
            var c_iframe = document.getElementById("c_iframe");
            c_iframe.src = c_iframe.src + "#" + b_width + "|" + b_height;
            // è¿™é‡Œé€šè¿‡hashä¼ é€’b.htmçš„å®½é«˜
        })();
    </script>
</body>

</html>
